//Name: Nick Hughes, Maximus Joe
//Student# : A01178826, A01256098

#include "SingletonFacade.hpp"
#include "Population.hpp"
#include "AlgorithmHandler.hpp"
#include <iostream>
#include <random>

using namespace std;

constexpr int CITIES_IN_TOUR = 32;
constexpr int POPULATION_SIZE = 32;
constexpr int TOTAL_ITERATIONS = 1000;
constexpr double IMPROVEMENT_FACTOR = 2.5;

//static definition of singletonFacade pointer
SingletonFacade *SingletonFacade::singletonFacade = nullptr;

//static definition of getInstance
SingletonFacade *SingletonFacade::GetInstance() {
    if (singletonFacade == nullptr) {
        singletonFacade = new SingletonFacade();
    }
    return singletonFacade;
}

void SingletonFacade::run() {

    // Random number generator from ranges 0.00 - 1000.00
    default_random_engine generator(time(nullptr));
    uniform_real_distribution<double> distribution(0, MAP_BOUNDARY);

    auto *population = new Population();
    Tour *cityList = new Tour();
    Tour *eliteTour = new Tour();


    // Create original city list
    for (int i = 0; i < CITIES_IN_TOUR; ++i) {
        cityList->add_city(new City(to_string(i + 1), distribution(generator), distribution(generator)));
    }

    // Create population of tours
    for (int i = 0; i < POPULATION_SIZE; ++i) {
        Tour *newTour = new Tour();
        newTour->set_cities(cityList->get_cities());
        std::shuffle(newTour->get_cities().begin(), newTour->get_cities().end(), generator);
        population->addTour(newTour);
    }

    // Print out total distance and fitness of all tours
    // Set eliteTour, base_distance, and eliteTourIndex
    int index = 1;
    int eliteTourIndex = 0;


    for (Tour *tour: population->getTours()) {
        double fitness = tour->determine_fitness();
        if (fitness > eliteTour->determine_fitness()) {
            eliteTourIndex = index;
            eliteTour = tour;
        }
        ++index;
    }

    Tour *originalElite = eliteTour;
    cout << "Original elite: Distance: " << originalElite->get_tour_distance() << endl;
    cout << *eliteTour;
    cout << "--- STARTING ALGORITHM ---" << endl;

    int iteration = 0;
    //While we haven't met our goal (or maxed out our iterations)
    while (iteration < TOTAL_ITERATIONS &&
           (originalElite->get_tour_distance() / eliteTour->get_tour_distance()) < IMPROVEMENT_FACTOR) {
        //Move the fittest tour (elite) to the front of the population
        swap(*population->getTours()[0], *population->getTours()[eliteTourIndex - 1]);
        //Create a temp list of tours called crosses
        vector<Tour *> crosses;
        //insert elite from initial list to the top of crosses
        crosses.push_back(population->getTours()[0]);


        //Create a temp list of tours which is copy of population's tours
        vector<Tour *> tempPop = population->getTours();
        //remove elite from population.getTours().
        tempPop.erase(tempPop.begin());
        //from the rest of the remaining tours, populate crosses.

        for (size_t i = 0; i < tempPop.size(); i++) {
            //create a new tour that is generated by crossing parents
            vector<Tour *> selectedTours = AlgorithmHandler::select_tours(tempPop);
            vector<City *> crossedCities = AlgorithmHandler::crossover(selectedTours);
            Tour *newTour = new Tour();
            newTour->set_cities(crossedCities);
            crosses.push_back(newTour);
        }

        vector<Tour *> toursToMutate;
        for (int i = 1; i < CITIES_IN_TOUR; i++) {
            toursToMutate.push_back(crosses[i]);
        }

        for (Tour *t: toursToMutate) {
            AlgorithmHandler::mutate(*t);
        }

        for (int i = 1; i < CITIES_IN_TOUR; i++) {
            crosses[i] = toursToMutate[i - 1];
        }

        index = 1;
        population->setTours(crosses);
        bool isNewElite = false;
        for (Tour *tour: population->getTours()) {
            double fitness = tour->determine_fitness();
            if (fitness > eliteTour->determine_fitness()) {
                isNewElite = true;
                eliteTourIndex = index;
                eliteTour = tour;
            }
            ++index;
        }

        cout << fixed << "Iteration: " << iteration << endl;
        if (isNewElite) {
            cout << "NEW ELITE FOUND:" << endl;
            cout << "Distance: " << fixed << setprecision(2) << eliteTour->get_tour_distance() << endl;
        } else {
            cout << "Elite distance: " << fixed << setprecision(2) << eliteTour->get_tour_distance() << endl;
            cout << "Best non-elite distance: " << population->getBestNonElite()->get_tour_distance() << endl;
        }
        cout << "Improvement over base: " << fixed << setprecision(5)
             << (originalElite->get_tour_distance() / eliteTour->get_tour_distance())
             << endl
             << endl;
        iteration++;
    }

    /** Print out final report. */
    cout << "--- FINISHED ALGORITHM ---" << endl;
    cout << "Total iterations: " << iteration << endl;
    cout << "Original elite: " << endl;
    cout << "Distance: " << fixed << setprecision(2) << originalElite->get_tour_distance() << endl;
    cout << *originalElite << endl;

    cout << "Best elite: " << endl;
    cout << "Distance: " << fixed << setprecision(2) << eliteTour->get_tour_distance() << endl;
    cout << *eliteTour << endl;
    cout << "Improvement factor" << (originalElite->get_tour_distance() / eliteTour->get_tour_distance() > IMPROVEMENT_FACTOR ? " reached!" : " not reached")
         << endl;
    cout << "Improvement factor: " << fixed << setprecision(5)
         << originalElite->get_tour_distance() / eliteTour->get_tour_distance() << endl;

    //delete master cityList here
    for (City *city: cityList->get_cities()) {
        delete city;
    }
    //delete dynamic memory pointers here too
    delete population;
    delete cityList;
    delete eliteTour;

}
